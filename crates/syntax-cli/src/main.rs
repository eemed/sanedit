use std::path::PathBuf;

use argh::FromArgs;
use sanedit_syntax::{Capture, Parser, Regex};

/// command line options
#[derive(FromArgs)]
struct Cli {
    /// interpret rules as regex
    #[argh(switch)]
    regex: bool,

    /// print rules
    #[argh(switch)]
    print_rules: bool,

    /// print generated byte code
    #[argh(switch)]
    print_byte_code: bool,

    /// print captures if matching was succesful
    #[argh(switch)]
    print_captures: bool,

    /// rules to parse with, either this or rule_file is required
    #[argh(option)]
    rules: Option<String>,

    /// rules to parse with, either this or rule_file is required
    #[argh(option)]
    rule_file: Option<PathBuf>,

    /// input file, if not provided use stdin
    #[argh(positional)]
    input: Option<PathBuf>,
}

fn read_rules(cli: &Cli) -> String {
    if let Some(rules) = &cli.rules {
        return rules.clone();
    }

    if let Some(file) = &cli.rule_file {
        use std::io::Read;
        let mut file = std::fs::File::open(file).unwrap();
        let mut rules = String::new();
        file.read_to_string(&mut rules).unwrap();
        return rules;
    }

    panic!("No rules provided. Use --rules or --rule-file");
}

fn get_reader(cli: &Cli) -> String {
    use std::io::Read;

    if let Some(file) = &cli.input {
        let mut file = std::fs::File::open(file).unwrap();
        let mut rules = String::new();
        file.read_to_string(&mut rules).unwrap();
        return rules;
    }

    let mut buffer = String::new();
    std::io::stdin().read_to_string(&mut buffer).unwrap();

    if buffer.is_empty() {
        panic!("No input provided. Use input positional or stdin");
    }

    buffer
}

fn print_capture_json(label: &str, cap: &Capture, last: bool) {
    println!(
        "  {{ \"label\": \"{}\", \"start\": {}, \"end\": {} }}{}",
        label,
        cap.range().start,
        cap.range().end,
        if last { "" } else { "," }
    );
}

fn print_captures_json(parser: &Parser, caps: &Vec<Capture>) {
    if caps.is_empty() {
        println!("[]");
        return;
    }

    println!("[");
    let mut iter = caps.iter().peekable();
    while let Some(cap) = iter.next() {
        let last = iter.peek().is_none();
        let label = parser.label_for(cap.id());
        print_capture_json(label, cap, last);
    }
    println!("]");
}

fn main() {
    let cli: Cli = argh::from_env();

    let rules = read_rules(&cli);
    let parser = if cli.regex {
        let rules = Regex::parse_pattern(&rules).unwrap();
        if cli.print_rules {
            println!("{rules}");
        }
        Regex::from_rules(rules).unwrap().into()
    } else {
        Parser::new(std::io::Cursor::new(rules)).unwrap()
    };

    if cli.print_byte_code {
        let prog = parser.program();
        println!("{prog:?}");
    }

    let reader = get_reader(&cli);

    if cli.regex {
        let mut found = false;
        let iter = parser.captures(reader.as_str());
        for caps in iter {
            found = true;

            if cli.print_captures {
                print_captures_json(&parser, &caps)
            }
        }

        if !found {
            std::process::exit(1)
        }

        return;
    }

    match parser.parse(reader.as_str()) {
        Ok(caps) => {
            if cli.print_captures {
                print_captures_json(&parser, &caps);
            }
        }
        Err(e) => {
            eprintln!("{e}");
            std::process::exit(1)
        }
    }
}
